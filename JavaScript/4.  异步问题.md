## ==4.== 异步问题

> - ~~**我要在 https://www.jianfast.com/ 网站上用js拿到下面网页内容打印在控制台:  https://www.douyin.com/user/MS4wLjABAAAAcOogp8WSlLvXNTPUg9b9brwWXQj76F9qeckY4T4w3kOzyuAMP-BFj2SbGqwIYwSZ?vid=7219194157544377637  请求方法: GET 返回 第一个`<p class="iQKjW6dr">`到页面**~~
>
>   你可以使用以下代码来获取页面内容并打印在控制台中:
>
>   ```javascript
>   fetch('https://www.douyin.com/user/MS4wLjABAAAAcOogp8WSlLvXNTPUg9b9brwWXQj76F9qeckY4T4w3kOzyuAMP-BFj2SbGqwIYwSZ?vid=7219194157544377637')
>     .then(response => response.text())
>     .then(text => {
>       let parser = new DOMParser();
>       let doc = parser.parseFromString(text, 'text/html');
>       let element = doc.querySelector('.iQKjW6dr');
>       console.log(element.textContent);
>     });
>   ```
>
>   请注意，这段代码可能不适用于所有网站，因为某些网站可能会阻止跨域请求。此外，如果页面结构发生变化，选择器也可能需要相应地进行更改。
>
>   ---
>
>   《如果报错《这个错误信息表明你的请求被CORS策略阻止了。CORS（跨域资源共享）是一种安全机制，它允许浏览器向不同域的服务器发送请求。然而，服务器需要在响应中包含一个`Access-Control-Allow-Origin`头，以指示浏览器允许来自特定域的请求。
>
>   在你的情况下，`https://www.douyin.com`服务器没有返回一个`Access-Control-Allow-Origin`头，所以浏览器阻止了你的请求。
>
>   有几种方法可以解决这个问题。一种方法是使用一个CORS代理，它会在你的请求和目标服务器之间充当中介，并在响应中添加适当的CORS头。另一种方法是在服务器端配置CORS策略，以允许来自你的域的请求。
>
>   请注意，更改服务器端的CORS策略需要对服务器有管理权限。》》
>
>
>
> ---
>
> - **fetch是什么**
>
>   `fetch()`是一个JavaScript函数，它提供了一种简单的方法来获取网络资源。它返回一个`Promise`，该`Promise`在资源可用时解析为一个`Response`对象。你可以使用`Response`对象的方法来检查响应的状态和获取响应的内容。
>
>   例如，你可以使用`response.text()`方法来获取响应的文本内容，或者使用`response.json()`方法来获取响应的JSON内容。
>
>   下面是一个简单的例子，它使用`fetch()`函数从网络上获取一个JSON文件，并在控制台中打印出它的内容:
>
>   ```javascript
>   fetch('<URL>')
>     .then(response => response.json())
>     .then(data => console.log(data));
>   ```
>
>   请注意，由于`fetch()`返回一个`Promise`，所以你需要使用`.then()`方法来处理响应。你也可以使用`async/await`语法来简化代码。
>
>   ---
>
>   >**用js爬 https://www.jianfast.com/  来个简单的demo**
>   >
>   >下面是一个简单的JavaScript爬虫示例，它使用`fetch()`函数从`https://www.jianfast.com/`获取页面内容，并使用`DOMParser`来解析HTML并提取页面标题:
>   >
>   >```javascript
>   >fetch('https://www.jianfast.com/')
>   >  .then(response => response.text())
>   >  .then(text => {
>   >    let parser = new DOMParser();
>   >    let doc = parser.parseFromString(text, 'text/html');
>   >    let title = doc.querySelector('title').textContent;
>   >    console.log(title);
>   >  });
>   >```
>   >
>   >请注意，这段代码可能不适用于所有网站，因为某些网站可能会阻止跨域请求。此外，如果页面结构发生变化，选择器也可能需要相应地进行更改。
>   >
>   >---
>   >
>   >**对于阻止跨域请求的网站应该怎么做呢**
>   >
>   >如果你遇到了阻止跨域请求的网站，你可以考虑使用以下方法之一来解决这个问题:
>   >
>   >1. **使用CORS代理**: 你可以使用一个CORS代理服务器，它会在你的请求和目标服务器之间充当中介，并在响应中添加适当的CORS头。这样，浏览器就可以接收到来自目标服务器的响应，而不会被CORS策略阻止。
>   >
>   >2. **在服务器端配置CORS策略**: 如果你有权访问目标服务器，你可以在服务器端配置CORS策略，以允许来自你的域的请求。这样，当浏览器向目标服务器发送请求时，服务器会在响应中包含一个`Access-Control-Allow-Origin`头，指示浏览器允许来自你的域的请求。
>   >
>   >3. **使用其他语言或工具**: 如果上述方法都不可行，你可以考虑使用其他语言（如Python或Ruby）或工具（如`curl`或`wget`）来获取网页内容。这些语言和工具通常不受浏览器的CORS策略限制，因此可以更容易地获取跨域资源。
>   >
>   >请注意，在使用爬虫程序获取网页内容时，请确保遵守网站的服务条款，并尊重服务器的资源限制。
>
>   ---
>
>   **那可以用`<iframe>`嵌入 https://www.jianfast.com/  再在`<iframe>`里面请求。可以应对跨域请求吗**
>
>   > 不行，使用`<iframe>`嵌入其他网站的内容并不能解决跨域请求的问题。即使你在`<iframe>`中嵌入了其他网站的内容，你仍然无法从父页面中访问`<iframe>`中的内容，除非两个页面都同意通过`postMessage` API进行通信。
>   >
>   > 此外，许多网站会使用`X-Frame-Options` HTTP头来阻止其他网站在`<iframe>`中嵌入它们的内容。这意味着，即使你尝试在`<iframe>`中嵌入其他网站的内容，浏览器也可能会阻止这种行为。
>   >
>   > 总之，使用`<iframe>`嵌入其他网站的内容并不能解决跨域请求的问题。你需要使用其他方法（如CORS代理或服务器端配置）来解决这个问题。
>   >
>   > >---
>   > >
>   > >**我想知道如何使用postMessage API进行通信。**
>   > >
>   > >`postMessage` API允许不同来源的窗口之间进行安全的通信。这意味着你可以使用`postMessage` API在`<iframe>`和父页面之间，或者在不同标签页之间传递消息。
>   > >
>   > >下面是一个简单的例子，它演示了如何在父页面和`<iframe>`之间使用`postMessage` API进行通信:
>   > >
>   > >**父页面:**
>   > >
>   > >```html
>   > ><iframe src="iframe.html" id="my-iframe"></iframe>
>   > >
>   > ><script>
>   > >  let iframe = document.querySelector('#my-iframe');
>   > >
>   > >  // 向iframe发送消息
>   > >  iframe.contentWindow.postMessage('Hello from parent!', '*');
>   > >
>   > >  // 监听来自iframe的消息
>   > >  window.addEventListener('message', event => {
>   > >    console.log('Received message from iframe:', event.data);
>   > >  });
>   > ></script>
>   > >```
>   > >
>   > >**iframe页面 (`iframe.html`):**
>   > >
>   > >```html
>   > ><script>
>   > >  // 监听来自父页面的消息
>   > >  window.addEventListener('message', event => {
>   > >    console.log('Received message from parent:', event.data);
>   > >
>   > >    // 向父页面发送消息
>   > >    event.source.postMessage('Hello from iframe!', event.origin);
>   > >  });
>   > ></script>
>   > >```
>   > >
>   > >在上面的例子中，父页面使用`postMessage`方法向`<iframe>`发送了一条消息。然后，`<iframe>`页面监听`message`事件，并在收到消息时向父页面发送一条回复。
>   > >
>   > >请注意，在使用`postMessage` API时，你应该始终验证消息的来源和数据，以确保通信的安全性。
>   > >
>   > >---
>   > >
>   > >**我想知道如何验证postMessage API中消息的来源和数据。**
>   > >
>   > >在使用`postMessage` API时，验证消息的来源和数据是非常重要的，以确保通信的安全性。下面是一些验证消息来源和数据的方法:
>   > >
>   > >1. **验证消息来源**: 当你监听`message`事件时，你可以检查`event.origin`属性来确定消息的来源。这个属性包含了发送消息的窗口的来源（即协议、主机名和端口）。你应该始终验证`event.origin`是否与你期望的来源匹配，以防止接收到来自不受信任来源的消息。
>   > >
>   > >2. **验证消息数据**: 在处理收到的消息时，你应该始终验证消息数据的格式和内容是否符合预期。例如，你可以检查数据是否为预期的类型（如字符串或对象），并验证数据中包含的字段是否符合预期。这样可以防止处理不符合预期的数据，从而提高应用程序的安全性。
>   > >
>   > >下面是一个简单的例子，它演示了如何在接收到`postMessage`消息时验证消息来源和数据:
>   > >
>   > >```javascript
>   > >window.addEventListener('message', event => {
>   > >  // 验证消息来源
>   > >  if (event.origin !== '<URL>') {
>   > >    console.log('Received message from unexpected origin:', event.origin);
>   > >    return;
>   > >  }
>   > >
>   > >  // 验证消息数据
>   > >  if (typeof event.data !== 'object' || !event.data.myField) {
>   > >    console.log('Received unexpected message data:', event.data);
>   > >    return;
>   > >  }
>   > >
>   > >  // 处理消息
>   > >  console.log('Received message:', event.data.myField);
>   > >});
>   > >```
>   > >
>   > >在上面的例子中，我们首先检查了`event.origin`属性，以确保消息来自预期的来源。然后，我们检查了消息数据的格式和内容，以确保它符合预期。只有当这些检查都通过时，我们才会处理收到的消息。


